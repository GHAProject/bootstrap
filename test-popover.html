<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Popover Test (Corrected Dependencies)</title>
    <link href="https://stackpath.bootstrapcdn.com/bootstrap/5.3.0/css/bootstrap.min.css" rel="stylesheet">
    <style>
        body { padding: 20px; }
        .container { margin-top: 50px; text-align: center; }
        #testPopover { padding: 10px 20px; font-size: 1.2em; }
        .instructions { margin-top: 30px; text-align: left; display: inline-block; }
    </style>
</head>
<body>
    <div class="container">
        <button type="button" class="btn btn-primary" id="testPopover" title="Test Popover"
            data-bs-toggle="popover" data-bs-placement="right" data-bs-trigger="hover click"
            data-bs-content="This is the popover content.">
            Test Popover
        </button>
        <div class="instructions">
            <h3>Manual Testing Instructions:</h3>
            <ol>
                <li><strong>Test 1: Click to open, mouseleave (should stay open)</strong><ul><li>Click the "Test Popover" button. Popover appears.</li><li>Move mouse away.</li><li><strong>Expected:</strong> Popover remains visible.</li></ul></li>
                <li><strong>Test 2: Click again to close (should close)</strong><ul><li>Ensure popover is open.</li><li>Click button again.</li><li><strong>Expected:</strong> Popover disappears.</li></ul></li>
                <li><strong>Test 3: Hover to open, mouseleave (should close)</strong><ul><li>Ensure popover is closed.</li><li>Hover button. Popover appears.</li><li>Move mouse away.</li><li><strong>Expected:</strong> Popover disappears.</li></ul></li>
                <li><strong>Test 4: Hover to open, click, mouseleave (should stay), click again (should close)</strong><ul><li>Ensure popover is closed.</li><li>Hover button. Popover appears.</li><li>Click button while popover is visible from hover.</li><li>Move mouse away.</li><li><strong>Expected:</strong> Popover remains visible.</li><li>Click button again.</li><li><strong>Expected:</strong> Popover disappears.</li></ul></li>
            </ol>
        </div>
    </div>

    <!-- Popper.js CDN -->
    <script src="https://unpkg.com/@popperjs/core@2"></script>

    <!-- Bootstrap JS Modules: Embedded -->
    <script type="module" id="bs-util-index">
    // js/src/util/index.js
    const MAX_UID = 1_000_000;
    const MILLISECONDS_MULTIPLIER = 1000;
    const TRANSITION_END = 'transitionend';
    const parseSelector = selector => {
      if (selector && window.CSS && window.CSS.escape) {
        selector = selector.replace(/#([^\s"#']+)/g, (match, id) => `#${CSS.escape(id)}`);
      }
      return selector;
    };
    const toType = object => {
      if (object === null || object === undefined) {
        return `${object}`;
      }
      return Object.prototype.toString.call(object).match(/\s([a-z]+)/i)[1].toLowerCase();
    };
    const getUID = prefix => {
      do {
        prefix += Math.floor(Math.random() * MAX_UID);
      } while (document.getElementById(prefix));
      return prefix;
    };
    const getTransitionDurationFromElement = element => {
      if (!element) {
        return 0;
      }
      let {
        transitionDuration,
        transitionDelay
      } = window.getComputedStyle(element);
      const floatTransitionDuration = Number.parseFloat(transitionDuration);
      const floatTransitionDelay = Number.parseFloat(transitionDelay);
      if (!floatTransitionDuration && !floatTransitionDelay) {
        return 0;
      }
      transitionDuration = transitionDuration.split(',')[0];
      transitionDelay = transitionDelay.split(',')[0];
      return (Number.parseFloat(transitionDuration) + Number.parseFloat(transitionDelay)) * MILLISECONDS_MULTIPLIER;
    };
    const triggerTransitionEnd = element => {
      element.dispatchEvent(new Event(TRANSITION_END));
    };
    const isElement = object => {
      if (!object || typeof object !== 'object') {
        return false;
      }
      if (typeof object.jquery !== 'undefined') {
        object = object[0];
      }
      return typeof object.nodeType !== 'undefined';
    };
    const getElement = object => {
      if (isElement(object)) {
        return object.jquery ? object[0] : object;
      }
      if (typeof object === 'string' && object.length > 0) {
        // Use a more robust selector query
        try {
            return document.querySelector(parseSelector(object));
        } catch (e) {
            console.warn(`Invalid selector: ${object}`, e);
            return null;
        }
      }
      return null;
    };
    const isVisible = element => {
      if (!isElement(element) || element.getClientRects().length === 0) {
        return false;
      }
      const elementIsVisible = getComputedStyle(element).getPropertyValue('visibility') === 'visible';
      const closedDetails = element.closest('details:not([open])');
      if (!closedDetails) {
        return elementIsVisible;
      }
      if (closedDetails !== element) {
        const summary = element.closest('summary');
        if (summary && summary.parentNode !== closedDetails) {
          return false;
        }
        if (summary === null) {
          return false;
        }
      }
      return elementIsVisible;
    };
    const isDisabled = element => {
      if (!element || element.nodeType !== Node.ELEMENT_NODE) {
        return true;
      }
      if (element.classList.contains('disabled')) {
        return true;
      }
      if (typeof element.disabled !== 'undefined') {
        return element.disabled;
      }
      return element.hasAttribute('disabled') && element.getAttribute('disabled') !== 'false';
    };
    const findShadowRoot = element => {
      if (!document.documentElement.attachShadow) {
        return null;
      }
      if (typeof element.getRootNode === 'function') {
        const root = element.getRootNode();
        return root instanceof ShadowRoot ? root : null;
      }
      if (element instanceof ShadowRoot) {
        return element;
      }
      if (!element.parentNode) {
        return null;
      }
      return findShadowRoot(element.parentNode);
    };
    const noop = () => {};
    const reflow = element => {
      element.offsetHeight;
    };
    const getjQuery = () => {
      if (window.jQuery && !document.body.hasAttribute('data-bs-no-jquery')) {
        return window.jQuery;
      }
      return null;
    };
    const DOMContentLoadedCallbacks = [];
    const onDOMContentLoaded = callback => {
      if (document.readyState === 'loading') {
        if (!DOMContentLoadedCallbacks.length) {
          document.addEventListener('DOMContentLoaded', () => {
            for (const cb of DOMContentLoadedCallbacks) {
              cb();
            }
          });
        }
        DOMContentLoadedCallbacks.push(callback);
      } else {
        callback();
      }
    };
    const isRTL = () => document.documentElement.dir === 'rtl';
    const defineJQueryPlugin = plugin => {
      onDOMContentLoaded(() => {
        const $ = getjQuery();
        if ($) {
          const name = plugin.NAME;
          const JQUERY_NO_CONFLICT = $.fn[name];
          $.fn[name] = plugin.jQueryInterface;
          $.fn[name].Constructor = plugin;
          $.fn[name].noConflict = () => {
            $.fn[name] = JQUERY_NO_CONFLICT;
            return plugin.jQueryInterface;
          };
        }
      });
    };
    const execute = (possibleCallback, args = [], defaultValue = possibleCallback) => {
      return typeof possibleCallback === 'function' ? possibleCallback.call(...args) : defaultValue;
    };
    const executeAfterTransition = (callback, transitionElement, waitForTransition = true) => {
      if (!waitForTransition) {
        execute(callback);
        return;
      }
      const durationPadding = 5;
      const emulatedDuration = getTransitionDurationFromElement(transitionElement) + durationPadding;
      let called = false;
      const handler = ({ target }) => {
        if (target !== transitionElement) {
          return;
        }
        called = true;
        transitionElement.removeEventListener(TRANSITION_END, handler);
        execute(callback);
      };
      transitionElement.addEventListener(TRANSITION_END, handler);
      setTimeout(() => {
        if (!called) {
          triggerTransitionEnd(transitionElement);
        }
      }, emulatedDuration);
    };
    const getNextActiveElement = (list, activeElement, shouldGetNext, isCycleAllowed) => {
      const listLength = list.length;
      let index = list.indexOf(activeElement);
      if (index === -1) {
        return !shouldGetNext && isCycleAllowed ? list[listLength - 1] : list[0];
      }
      index += shouldGetNext ? 1 : -1;
      if (isCycleAllowed) {
        index = (index + listLength) % listLength;
      }
      return list[Math.max(0, Math.min(index, listLength - 1))];
    };
    // Export all functions for other modules to import by name
    export { defineJQueryPlugin, execute, executeAfterTransition, findShadowRoot, getElement, getjQuery, getNextActiveElement, getTransitionDurationFromElement, getUID, isDisabled, isElement, isRTL, isVisible, noop, onDOMContentLoaded, parseSelector, reflow, triggerTransitionEnd, toType };
    </script>

    <script type="module" id="bs-dom-data">
    // js/src/dom/data.js
    const elementMap = new Map();
    const Data = { // Renamed export to Data to match usage in BaseComponent
      set(element, key, instance) {
        if (!elementMap.has(element)) {
          elementMap.set(element, new Map());
        }
        const instanceMap = elementMap.get(element);
        if (!instanceMap.has(key) && instanceMap.size !== 0) {
          console.error(`Bootstrap doesn't allow more than one instance per element. Bound instance: ${Array.from(instanceMap.keys())[0]}.`);
          return;
        }
        instanceMap.set(key, instance);
      },
      get(element, key) {
        if (elementMap.has(element)) {
          return elementMap.get(element).get(key) || null;
        }
        return null;
      },
      remove(element, key) {
        if (!elementMap.has(element)) {
          return;
        }
        const instanceMap = elementMap.get(element);
        instanceMap.delete(key);
        if (instanceMap.size === 0) {
          elementMap.delete(element);
        }
      }
    };
    export default Data; // Default export
    </script>

    <script type="module" id="bs-dom-selector-engine">
    // js/src/dom/selector-engine.js
    // Adjusted import to directly use named exports from bs-util-index
    import { isDisabled, isVisible, parseSelector as utilParseSelector } from '#bs-util-index';

    const getSelector = element => {
      let selector = element.getAttribute('data-bs-target');
      if (!selector || selector === '#') {
        let hrefAttribute = element.getAttribute('href');
        if (!hrefAttribute || (!hrefAttribute.includes('#') && !hrefAttribute.startsWith('.'))) {
          return null;
        }
        if (hrefAttribute.includes('#') && !hrefAttribute.startsWith('#')) {
          hrefAttribute = `#${hrefAttribute.split('#')[1]}`;
        }
        selector = hrefAttribute && hrefAttribute !== '#' ? hrefAttribute.trim() : null;
      }
      // Use the imported parseSelector
      return selector ? selector.split(',').map(sel => utilParseSelector(sel)).join(',') : null;
    };
    const SelectorEngine = {
      find(selector, element = document.documentElement) {
        return [].concat(...Element.prototype.querySelectorAll.call(element, selector));
      },
      findOne(selector, element = document.documentElement) {
        return Element.prototype.querySelector.call(element, selector);
      },
      children(element, selector) {
        return [].concat(...element.children).filter(child => child.matches(selector));
      },
      parents(element, selector) {
        const parents = [];
        let ancestor = element.parentNode.closest(selector);
        while (ancestor) {
          parents.push(ancestor);
          ancestor = ancestor.parentNode.closest(selector);
        }
        return parents;
      },
      prev(element, selector) {
        let previous = element.previousElementSibling;
        while (previous) {
          if (previous.matches(selector)) {
            return [previous];
          }
          previous = previous.previousElementSibling;
        }
        return [];
      },
      next(element, selector) {
        let next = element.nextElementSibling;
        while (next) {
          if (next.matches(selector)) {
            return [next];
          }
          next = next.nextElementSibling;
        }
        return [];
      },
      focusableChildren(element) {
        const focusables = ['a', 'button', 'input', 'textarea', 'select', 'details', '[tabindex]', '[contenteditable="true"]'].map(s => `${s}:not([tabindex^="-"])`).join(',');
        return this.find(focusables, element).filter(el => !isDisabled(el) && isVisible(el));
      },
      getSelectorFromElement(element) {
        const selector = getSelector(element);
        if (selector) {
          return SelectorEngine.findOne(selector) ? selector : null;
        }
        return null;
      },
      getElementFromSelector(element) {
        const selector = getSelector(element);
        return selector ? SelectorEngine.findOne(selector) : null;
      },
      getMultipleElementsFromSelector(element) {
        const selector = getSelector(element);
        return selector ? SelectorEngine.find(selector) : [];
      }
    };
    export default SelectorEngine;
    </script>

    <script type="module" id="bs-dom-manipulator">
    // js/src/dom/manipulator.js
    // No internal Bootstrap imports for this specific file's content
    function normalizeData(value) {
      if (value === 'true') { return true; }
      if (value === 'false') { return false; }
      if (value === Number(value).toString()) { return Number(value); }
      if (value === '' || value === 'null') { return null; }
      if (typeof value !== 'string') { return value; }
      try { return JSON.parse(decodeURIComponent(value)); } catch { return value; }
    }
    function normalizeDataKey(key) { return key.replace(/[A-Z]/g, chr => `-${chr.toLowerCase()}`); }
    const Manipulator = {
      setDataAttribute(element, key, value) { element.setAttribute(`data-bs-${normalizeDataKey(key)}`, value); },
      removeDataAttribute(element, key) { element.removeAttribute(`data-bs-${normalizeDataKey(key)}`); },
      getDataAttributes(element) {
        if (!element) { return {}; }
        const attributes = {};
        const bsKeys = Object.keys(element.dataset).filter(key => key.startsWith('bs') && !key.startsWith('bsConfig'));
        for (const key of bsKeys) {
          let pureKey = key.replace(/^bs/, '');
          pureKey = pureKey.charAt(0).toLowerCase() + pureKey.slice(1);
          attributes[pureKey] = normalizeData(element.dataset[key]);
        }
        return attributes;
      },
      getDataAttribute(element, key) { return normalizeData(element.getAttribute(`data-bs-${normalizeDataKey(key)}`)); }
    };
    export default Manipulator;
    </script>

    <script type="module" id="bs-dom-event-handler">
    // js/src/dom/event-handler.js
    import { getjQuery as utilGetjQuery } from '#bs-util-index'; // Use named import

    const namespaceRegex = /[^.]*(?=\..*)\.|.*/;
    const stripNameRegex = /\..*/;
    const stripUidRegex = /::\d+$/;
    const eventRegistry = {};
    let uidEvent = 1;
    const customEvents = { mouseenter: 'mouseover', mouseleave: 'mouseout' };
    const nativeEvents = new Set(['click','dblclick','mouseup','mousedown','contextmenu','mousewheel','DOMMouseScroll','mouseover','mouseout','mousemove','selectstart','selectend','keydown','keypress','keyup','orientationchange','touchstart','touchmove','touchend','touchcancel','pointerdown','pointermove','pointerup','pointerleave','pointercancel','gesturestart','gesturechange','gestureend','focus','blur','change','reset','select','submit','focusin','focusout','load','unload','beforeunload','resize','move','DOMContentLoaded','readystatechange','error','abort','scroll']);

    function makeEventUid(element, uid) { return (uid && `${uid}::${uidEvent++}`) || element.uidEvent || uidEvent++; }
    function getElementEvents(element) {
      const uid = makeEventUid(element);
      element.uidEvent = uid;
      eventRegistry[uid] = eventRegistry[uid] || {};
      return eventRegistry[uid];
    }
    function bootstrapHandler(element, fn) {
      return function handler(event) {
        hydrateObj(event, { delegateTarget: element });
        if (handler.oneOff) { EventHandler.off(element, event.type, fn); }
        return fn.apply(element, [event]);
      };
    }
    function bootstrapDelegationHandler(element, selector, fn) {
      return function handler(event) {
        const domElements = element.querySelectorAll(selector); // SelectorEngine.find could be used here too
        for (let { target } = event; target && target !== this; target = target.parentNode) {
          for (const domElement of domElements) {
            if (domElement !== target) { continue; }
            hydrateObj(event, { delegateTarget: target });
            if (handler.oneOff) { EventHandler.off(element, event.type, selector, fn); }
            return fn.apply(target, [event]);
          }
        }
      };
    }
    function findHandler(events, callable, delegationSelector = null) { return Object.values(events).find(event => event.callable === callable && event.delegationSelector === delegationSelector); }
    function normalizeParameters(originalTypeEvent, handler, delegationFunction) {
      const isDelegated = typeof handler === 'string';
      const callable = isDelegated ? delegationFunction : (handler || delegationFunction);
      let typeEvent = getTypeEvent(originalTypeEvent);
      if (!nativeEvents.has(typeEvent)) { typeEvent = originalTypeEvent; }
      return [isDelegated, callable, typeEvent];
    }
    function addHandler(element, originalTypeEvent, handler, delegationFunction, oneOff) {
      if (typeof originalTypeEvent !== 'string' || !element) { return; }
      let [isDelegated, callable, typeEvent] = normalizeParameters(originalTypeEvent, handler, delegationFunction);
      if (originalTypeEvent in customEvents) {
        const wrapFunction = fn => function (event) {
          if (!event.relatedTarget || (event.relatedTarget !== event.delegateTarget && !event.delegateTarget.contains(event.relatedTarget))) {
            return fn.call(this, event);
          }
        };
        callable = wrapFunction(callable);
      }
      const events = getElementEvents(element);
      const handlers = events[typeEvent] || (events[typeEvent] = {});
      const previousFunction = findHandler(handlers, callable, isDelegated ? handler : null);
      if (previousFunction) { previousFunction.oneOff = previousFunction.oneOff && oneOff; return; }
      const uid = makeEventUid(callable, originalTypeEvent.replace(namespaceRegex, ''));
      const fn = isDelegated ? bootstrapDelegationHandler(element, handler, callable) : bootstrapHandler(element, callable);
      fn.delegationSelector = isDelegated ? handler : null; fn.callable = callable; fn.oneOff = oneOff; fn.uidEvent = uid;
      handlers[uid] = fn;
      element.addEventListener(typeEvent, fn, isDelegated);
    }
    function removeHandler(element, events, typeEvent, handler, delegationSelector) {
      const fn = findHandler(events[typeEvent], handler, delegationSelector);
      if (!fn) { return; }
      element.removeEventListener(typeEvent, fn, Boolean(delegationSelector));
      delete events[typeEvent][fn.uidEvent];
    }
    function removeNamespacedHandlers(element, events, typeEvent, namespace) {
      const storeElementEvent = events[typeEvent] || {};
      for (const [handlerKey, event] of Object.entries(storeElementEvent)) {
        if (handlerKey.includes(namespace)) {
          removeHandler(element, events, typeEvent, event.callable, event.delegationSelector);
        }
      }
    }
    function getTypeEvent(event) { event = event.replace(stripNameRegex, ''); return customEvents[event] || event; }
    const EventHandler = {
      on(element, event, handler, delegationFunction) { addHandler(element, event, handler, delegationFunction, false); },
      one(element, event, handler, delegationFunction) { addHandler(element, event, handler, delegationFunction, true); },
      off(element, originalTypeEvent, handler, delegationFunction) {
        if (typeof originalTypeEvent !== 'string' || !element) { return; }
        const [isDelegated, callable, typeEvent] = normalizeParameters(originalTypeEvent, handler, delegationFunction);
        const inNamespace = typeEvent !== originalTypeEvent;
        const events = getElementEvents(element);
        const storeElementEvent = events[typeEvent] || {};
        const isNamespace = originalTypeEvent.startsWith('.');
        if (typeof callable !== 'undefined') {
          if (!Object.keys(storeElementEvent).length) { return; }
          removeHandler(element, events, typeEvent, callable, isDelegated ? handler : null); return;
        }
        if (isNamespace) {
          for (const elementEvent of Object.keys(events)) {
            removeNamespacedHandlers(element, events, elementEvent, originalTypeEvent.slice(1));
          }
        }
        for (const [keyHandlers, event] of Object.entries(storeElementEvent)) {
          const handlerKey = keyHandlers.replace(stripUidRegex, '');
          if (!inNamespace || originalTypeEvent.includes(handlerKey)) {
            removeHandler(element, events, typeEvent, event.callable, event.delegationSelector);
          }
        }
      },
      trigger(element, event, args) {
        if (typeof event !== 'string' || !element) { return null; }
        const $ = utilGetjQuery(); // Use imported getjQuery
        const typeEvent = getTypeEvent(event);
        const inNamespace = event !== typeEvent;
        let jQueryEvent = null; let bubbles = true; let nativeDispatch = true; let defaultPrevented = false;
        if (inNamespace && $) {
          jQueryEvent = $.Event(event, args);
          $(element).trigger(jQueryEvent);
          bubbles = !jQueryEvent.isPropagationStopped();
          nativeDispatch = !jQueryEvent.isImmediatePropagationStopped();
          defaultPrevented = jQueryEvent.isDefaultPrevented();
        }
        const evt = hydrateObj(new Event(event, { bubbles, cancelable: true }), args);
        if (defaultPrevented) { evt.preventDefault(); }
        if (nativeDispatch) { element.dispatchEvent(evt); }
        if (evt.defaultPrevented && jQueryEvent) { jQueryEvent.preventDefault(); }
        return evt;
      }
    };
    function hydrateObj(obj, meta = {}) {
      for (const [key, value] of Object.entries(meta)) {
        try { obj[key] = value; } catch { Object.defineProperty(obj, key, { configurable: true, get() { return value; } }); }
      }
      return obj;
    }
    export default EventHandler;
    </script>

    <script type="module" id="bs-util-sanitizer">
    // js/src/util/sanitizer.js
    const ARIA_ATTRIBUTE_PATTERN = /^aria-[\w-]*$/i;
    const DefaultAllowlist = { // Exporting this directly
      '*': ['class', 'dir', 'id', 'lang', 'role', ARIA_ATTRIBUTE_PATTERN],
      a: ['target', 'href', 'title', 'rel'], area: [], b: [], br: [], col: [], code: [], dd: [], div: [], dl: [], dt: [], em: [], hr: [],
      h1: [], h2: [], h3: [], h4: [], h5: [], h6: [], i: [], img: ['src', 'srcset', 'alt', 'title', 'width', 'height'],
      li: [], ol: [], p: [], pre: [], s: [], small: [], span: [], sub: [], sup: [], strong: [], u: [], ul: []
    };
    const uriAttributes = new Set(['background', 'cite', 'href', 'itemtype', 'longdesc', 'poster', 'src', 'xlink:href']);
    const SAFE_URL_PATTERN = /^(?!javascript:)(?:[a-z0-9+.-]+:|[^&:/?#]*(?:[/?#]|$))/i;
    const allowedAttribute = (attribute, allowedAttributeList) => {
      const attributeName = attribute.nodeName.toLowerCase();
      if (allowedAttributeList.includes(attributeName)) {
        if (uriAttributes.has(attributeName)) { return Boolean(SAFE_URL_PATTERN.test(attribute.nodeValue)); }
        return true;
      }
      return allowedAttributeList.filter(attributeRegex => attributeRegex instanceof RegExp).some(regex => regex.test(attributeName));
    };
    function sanitizeHtml(unsafeHtml, allowList, sanitizeFunction) { // Exporting this directly
      if (!unsafeHtml.length) { return unsafeHtml; }
      if (sanitizeFunction && typeof sanitizeFunction === 'function') { return sanitizeFunction(unsafeHtml); }
      const domParser = new window.DOMParser();
      const createdDocument = domParser.parseFromString(unsafeHtml, 'text/html');
      const elements = [].concat(...createdDocument.body.querySelectorAll('*'));
      for (const element of elements) {
        const elementName = element.nodeName.toLowerCase();
        if (!Object.keys(allowList).includes(elementName)) { element.remove(); continue; }
        const attributeList = [].concat(...element.attributes);
        const allowedAttributes = [].concat(allowList['*'] || [], allowList[elementName] || []);
        for (const attribute of attributeList) {
          if (!allowedAttribute(attribute, allowedAttributes)) { element.removeAttribute(attribute.nodeName); }
        }
      }
      return createdDocument.body.innerHTML;
    }
    export { DefaultAllowlist, sanitizeHtml }; // Named exports
    </script>

    <script type="module" id="bs-config">
    // js/src/util/config.js (Simulated as its own module for clarity)
    import Manipulator from '#bs-dom-manipulator';
    import { isElement as utilIsElement, toType as utilToType } from '#bs-util-index';

    class Config {
      static get Default() { return {}; }
      static get DefaultType() { return {}; }
      static get NAME() { throw new Error('You have to implement the static method "NAME", for each component!'); }
      _getConfig(config) {
        config = this._mergeConfigObj(config, this._element); // _element must be set by child class
        config = this._configAfterMerge(config);
        this._typeCheckConfig(config);
        return config;
      }
      _configAfterMerge(config) { return config; }
      _mergeConfigObj(config, element) { // element is optional
        const jsonConfig = utilIsElement(element) ? Manipulator.getDataAttribute(element, 'config') : {};
        return {
          ...this.constructor.Default,
          ...(typeof jsonConfig === 'object' ? jsonConfig : {}),
          ...(utilIsElement(element) ? Manipulator.getDataAttributes(element) : {}),
          ...(typeof config === 'object' ? config : {})
        };
      }
      _typeCheckConfig(config, configTypes = this.constructor.DefaultType) {
        for (const [property, expectedTypes] of Object.entries(configTypes)) {
          const value = config[property];
          const valueType = utilIsElement(value) ? 'element' : utilToType(value);
          if (!new RegExp(expectedTypes).test(valueType)) {
            throw new TypeError(`${this.constructor.NAME.toUpperCase()}: Option "${property}" provided type "${valueType}" but expected type "${expectedTypes}".`);
          }
        }
      }
    }
    export default Config;
    </script>

    <script type="module" id="bs-base-component">
    // js/src/base-component.js
    import Data from '#bs-dom-data';
    import EventHandler from '#bs-dom-event-handler';
    import Config from '#bs-config'; // Uses the new bs-config module
    import { executeAfterTransition as utilExecuteAfterTransition, getElement as utilGetElement } from '#bs-util-index';

    const VERSION = '5.3.x';
    class BaseComponent extends Config { // Extends the Config module
      constructor(element, config) {
        super(); // Calls Config constructor
        this._element = utilGetElement(element); // _element is used by Config's _getConfig
        if (!this._element) { return; }
        // this._config is initialized by super._getConfig() implicitly if not called directly
        this._config = this._getConfig(config); // Now calls Config._getConfig
        Data.set(this._element, this.constructor.DATA_KEY, this);
      }
      dispose() {
        Data.remove(this._element, this.constructor.DATA_KEY);
        EventHandler.off(this._element, this.constructor.EVENT_KEY);
        for (const propertyName of Object.getOwnPropertyNames(this)) {
          this[propertyName] = null;
        }
      }
      _queueCallback(callback, element, isAnimated = true) { utilExecuteAfterTransition(callback, element, isAnimated); }
      static getInstance(element) { return Data.get(utilGetElement(element), this.DATA_KEY); }
      static getOrCreateInstance(element, config = {}) {
        return this.getInstance(element) || new this(element, typeof config === 'object' ? config : null);
      }
      static get VERSION() { return VERSION; }
      static get DATA_KEY() { return `bs.${this.NAME}`; } // NAME must be static in child
      static get EVENT_KEY() { return `.${this.DATA_KEY}`; }
      static eventName(name) { return `${name}${this.EVENT_KEY}`; }
    }
    export default BaseComponent;
    </script>

    <script type="module" id="bs-util-template-factory">
    // js/src/util/template-factory.js
    import SelectorEngine from '#bs-dom-selector-engine';
    import Config from '#bs-config'; // Uses the new bs-config module
    import { DefaultAllowlist as SanitizeDefaultAllowlist, sanitizeHtml as SanitizeSanitizeHtml } from '#bs-util-sanitizer';
    import { execute as utilExecute, getElement as utilGetElement, isElement as utilIsElement } from '#bs-util-index';

    const NAME = 'TemplateFactory'; // Static NAME for Config parent
    const Default = {
      allowList: SanitizeDefaultAllowlist, content: {}, extraClass: '', html: false, sanitize: true, sanitizeFn: null, template: '<div></div>'
    };
    const DefaultType = {
      allowList: 'object', content: 'object', extraClass: '(string|function)', html: 'boolean', sanitize: 'boolean', sanitizeFn: '(null|function)', template: 'string'
    };
    const DefaultContentType = { entry: '(string|element|function|null)', selector: '(string|element)' };

    class TemplateFactory extends Config {
      constructor(config) {
        super();
        this._config = this._getConfig(config); // Calls Config._getConfig
      }
      static get Default() { return Default; }
      static get DefaultType() { return DefaultType; }
      static get NAME() { return NAME; } // Required by Config

      getContent() { return Object.values(this._config.content).map(c => this._resolvePossibleFunction(c)).filter(Boolean); }
      hasContent() { return this.getContent().length > 0; }
      changeContent(content) {
        this._checkContent(content);
        this._config.content = { ...this._config.content, ...content };
        return this;
      }
      toHtml() {
        const templateWrapper = document.createElement('div');
        templateWrapper.innerHTML = this._maybeSanitize(this._config.template);
        for (const [selector, text] of Object.entries(this._config.content)) { this._setContent(templateWrapper, text, selector); }
        const template = templateWrapper.children[0];
        const extraClass = this._resolvePossibleFunction(this._config.extraClass);
        if (extraClass) { template.classList.add(...extraClass.split(' ')); }
        return template;
      }
      _typeCheckConfig(config) { super._typeCheckConfig(config); this._checkContent(config.content); } // Extends Config._typeCheckConfig
      _checkContent(arg) {
        for (const [selector, content] of Object.entries(arg)) { super._typeCheckConfig({ selector, entry: content }, DefaultContentType); }
      }
      _setContent(template, content, selector) {
        const te = SelectorEngine.findOne(selector, template);
        if (!te) { return; }
        content = this._resolvePossibleFunction(content);
        if (!content) { te.remove(); return; }
        if (utilIsElement(content)) { this._putElementInTemplate(utilGetElement(content), te); return; }
        if (this._config.html) { te.innerHTML = this._maybeSanitize(content); return; }
        te.textContent = content;
      }
      _maybeSanitize(arg) { return this._config.sanitize ? SanitizeSanitizeHtml(arg, this._config.allowList, this._config.sanitizeFn) : arg; }
      _resolvePossibleFunction(arg) { return utilExecute(arg, [this]); }
      _putElementInTemplate(element, templateElement) {
        if (this._config.html) { templateElement.innerHTML = ''; templateElement.append(element); return; }
        templateElement.textContent = element.textContent;
      }
    }
    export default TemplateFactory;
    </script>

    <script type="module" id="bs-tooltip">
    // js/src/tooltip.js (MODIFIED)
    // Popper is imported globally from CDN
    import BaseComponent from '#bs-base-component';
    import EventHandler from '#bs-dom-event-handler';
    import Manipulator from '#bs-dom-manipulator';
    import { defineJQueryPlugin as utilDefineJQueryPlugin, execute as utilExecute, findShadowRoot as utilFindShadowRoot, getElement as utilGetElement, getUID as utilGetUID, isRTL as utilIsRTL, noop as utilNoop } from '#bs-util-index';
    import { DefaultAllowlist as SanitizerDefaultAllowlist } from '#bs-util-sanitizer';
    import TemplateFactory from '#bs-util-template-factory';

    const NAME = 'tooltip'; // Static NAME for BaseComponent
    const DISALLOWED_ATTRIBUTES = new Set(['sanitize', 'allowList', 'sanitizeFn']);
    const CLASS_NAME_FADE = 'fade', CLASS_NAME_MODAL = 'modal', CLASS_NAME_SHOW = 'show';
    const SELECTOR_TOOLTIP_INNER = '.tooltip-inner', SELECTOR_MODAL = `.${CLASS_NAME_MODAL}`;
    const EVENT_MODAL_HIDE = 'hide.bs.modal';
    const TRIGGER_HOVER = 'hover', TRIGGER_FOCUS = 'focus', TRIGGER_CLICK = 'click', TRIGGER_MANUAL = 'manual';
    const EVENT_HIDE = 'hide', EVENT_HIDDEN = 'hidden', EVENT_SHOW = 'show', EVENT_SHOWN = 'shown', EVENT_INSERTED = 'inserted';
    const EVENT_CLICK_BS = 'click'; // Renamed for clarity
    const EVENT_FOCUSIN = 'focusin', EVENT_FOCUSOUT = 'focusout', EVENT_MOUSEENTER = 'mouseenter', EVENT_MOUSELEAVE = 'mouseleave';

    const AttachmentMap = { AUTO: 'auto', TOP: 'top', RIGHT: utilIsRTL() ? 'left' : 'right', BOTTOM: 'bottom', LEFT: utilIsRTL() ? 'right' : 'left' };
    const Default = {
      allowList: SanitizerDefaultAllowlist, animation: true, boundary: 'clippingParents', container: false, customClass: '', delay: 0,
      fallbackPlacements: ['top', 'right', 'bottom', 'left'], html: false, offset: [0, 6], placement: 'top', popperConfig: null,
      sanitize: true, sanitizeFn: null, selector: false,
      template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
      title: '', trigger: 'hover focus'
    };
    const DefaultType = {
      allowList: 'object', animation: 'boolean', boundary: '(string|element)', container: '(string|element|boolean)', customClass: '(string|function)',
      delay: '(number|object)', fallbackPlacements: 'array', html: 'boolean', offset: '(array|string|function)', placement: '(string|function)',
      popperConfig: '(null|object|function)', sanitize: 'boolean', sanitizeFn: '(null|function)', selector: '(string|boolean)',
      template: 'string', title: '(string|element|function)', trigger: 'string'
    };

    class Tooltip extends BaseComponent {
      constructor(element, config) {
        if (typeof Popper === 'undefined') { throw new TypeError('Bootstrap\\\'s tooltips require Popper (https://popper.js.org/docs/v2/)'); }
        super(element, config); // Calls BaseComponent constructor
        this._isEnabled = true; this._timeout = 0; this._isHovered = null; this._activeTrigger = {};
        this._popper = null; this._templateFactory = null; this._newContent = null; this.tip = null;
        this._setListeners();
        if (!this._config.selector) { this._fixTitle(); }
      }
      static get Default() { return Default; }
      static get DefaultType() { return DefaultType; }
      static get NAME() { return NAME; } // From BaseComponent
      enable() { this._isEnabled = true; }
      disable() { this._isEnabled = false; }
      toggleEnabled() { this._isEnabled = !this._isEnabled; }
      toggle() {
        if (!this._isEnabled) { return; }
        if (this._isShown()) { this._leave(); return; }
        this._enter();
      }
      dispose() {
        clearTimeout(this._timeout);
        const closestModal = this._element ? this._element.closest(SELECTOR_MODAL) : null;
        if (closestModal) { EventHandler.off(closestModal, EVENT_MODAL_HIDE, this._hideModalHandler); }
        if (this._element && this._element.getAttribute('data-bs-original-title')) {
          this._element.setAttribute('title', this._element.getAttribute('data-bs-original-title'));
        }
        this._disposePopper();
        super.dispose();
      }
      show() {
        if (this._element.style.display === 'none') { throw new Error('Please use show on visible elements'); }
        if (!(this._isWithContent() && this._isEnabled)) { return; }
        const showEvent = EventHandler.trigger(this._element, this.constructor.eventName(EVENT_SHOW));
        const shadowRoot = utilFindShadowRoot(this._element);
        const isInTheDom = (shadowRoot || this._element.ownerDocument.documentElement).contains(this._element);
        if (showEvent.defaultPrevented || !isInTheDom) { return; }
        this._disposePopper();
        const tip = this._getTipElement();
        this._element.setAttribute('aria-describedby', tip.getAttribute('id'));
        const { container } = this._config;
        const targetContainer = utilGetElement(container) || document.body; // Ensure container is an element
        if (!targetContainer.contains(this.tip)) { // Check if tip is already in the resolved container
            targetContainer.append(tip);
            EventHandler.trigger(this._element, this.constructor.eventName(EVENT_INSERTED));
        }
        this._popper = Popper.createPopper(this._element, tip, this._getPopperConfig(AttachmentMap[this._config.placement.toUpperCase()] || this._config.placement));
        tip.classList.add(CLASS_NAME_SHOW);
        if ('ontouchstart' in document.documentElement) {
          [].concat(...document.body.children).forEach(el => EventHandler.on(el, 'mouseover', utilNoop));
        }
        const complete = () => {
          EventHandler.trigger(this._element, this.constructor.eventName(EVENT_SHOWN));
          if (this._isHovered === false) { this._leave(); }
          this._isHovered = false;
        };
        this._queueCallback(complete, this.tip, this._isAnimated());
      }
      hide() {
        if (!this._isShown()) { return; }
        const hideEvent = EventHandler.trigger(this._element, this.constructor.eventName(EVENT_HIDE));
        if (hideEvent.defaultPrevented) { return; }
        const tip = this._getTipElement();
        tip.classList.remove(CLASS_NAME_SHOW);
        if ('ontouchstart' in document.documentElement) {
          [].concat(...document.body.children).forEach(el => EventHandler.off(el, 'mouseover', utilNoop));
        }
        this._activeTrigger[TRIGGER_CLICK] = false; this._activeTrigger[TRIGGER_FOCUS] = false; this._activeTrigger[TRIGGER_HOVER] = false;
        this._isHovered = null;
        const complete = () => {
          if (this._isWithActiveTrigger()) { return; }
          if (!this._isHovered && this.tip) { this._disposePopper(); } // Check this.tip exists
          if(this._element) this._element.removeAttribute('aria-describedby');
          EventHandler.trigger(this._element, this.constructor.eventName(EVENT_HIDDEN));
        };
        this._queueCallback(complete, this.tip, this._isAnimated());
      }
      update() { if (this._popper) { this._popper.update(); } }
      _isWithContent() { return Boolean(this._getTitle()); }
      _getTipElement() {
        if (!this.tip) { this.tip = this._createTipElement(this._newContent || this._getContentForTemplate()); }
        return this.tip;
      }
      _createTipElement(content) {
        const tip = this._getTemplateFactory(content).toHtml();
        if (!tip) { return null; }
        tip.classList.remove(CLASS_NAME_FADE, CLASS_NAME_SHOW);
        tip.classList.add(`bs-${this.constructor.NAME}-auto`);
        const tipId = utilGetUID(this.constructor.NAME).toString();
        tip.setAttribute('id', tipId);
        if (this._isAnimated()) { tip.classList.add(CLASS_NAME_FADE); }
        return tip;
      }
      setContent(content) {
        this._newContent = content;
        if (this._isShown()) { this._disposePopper(); this.show(); }
      }
      _getTemplateFactory(content) {
        if (this._templateFactory) { this._templateFactory.changeContent(content); }
        else {
          this._templateFactory = new TemplateFactory({
            ...this._config, content, extraClass: this._resolvePossibleFunction(this._config.customClass)
          });
        }
        return this._templateFactory;
      }
      _getContentForTemplate() { return { [SELECTOR_TOOLTIP_INNER]: this._getTitle() }; }
      _getTitle() { return this._resolvePossibleFunction(this._config.title) || (this._element ? this._element.getAttribute('data-bs-original-title') : ''); }
      _initializeOnDelegatedTarget(event) { return this.constructor.getOrCreateInstance(event.delegateTarget, this._getDelegateConfig()); }
      _isAnimated() { return this._config.animation || (this.tip && this.tip.classList.contains(CLASS_NAME_FADE)); }
      _isShown() { return this.tip && this.tip.classList.contains(CLASS_NAME_SHOW); }
      _createPopper(tipEl) { // Renamed tip to tipEl
        const placement = utilExecute(this._config.placement, [this, tipEl, this._element]) || AttachmentMap.AUTO;
        const attachment = AttachmentMap[placement.toUpperCase()] || placement;
        return Popper.createPopper(this._element, tipEl, this._getPopperConfig(attachment));
      }
      _getOffset() {
        const { offset } = this._config;
        if (typeof offset === 'string') { return offset.split(',').map(v => Number.parseInt(v, 10)); }
        if (typeof offset === 'function') { return popperData => offset(popperData, this._element); }
        return offset;
      }
      _resolvePossibleFunction(arg) { return utilExecute(arg, [this._element]); }
      _getPopperConfig(attachment) {
        const defaultBsConfig = {
          placement: attachment,
          modifiers: [
            { name: 'flip', options: { fallbackPlacements: this._config.fallbackPlacements }},
            { name: 'offset', options: { offset: this._getOffset() }},
            { name: 'preventOverflow', options: { boundary: this._config.boundary }},
            { name: 'arrow', options: { element: `.${this.constructor.NAME}-arrow` }},
            { name: 'preSetPlacement', enabled: true, phase: 'beforeMain', fn: data => {
                if(this.tip) this.tip.setAttribute('data-popper-placement', data.state.placement);
            }}
          ]
        };
        return { ...defaultBsConfig, ...utilExecute(this._config.popperConfig, [defaultBsConfig]) };
      }
      _setListeners() {
        const triggers = this._config.trigger.split(' ');
        for (const trigger of triggers) {
          if (trigger === TRIGGER_CLICK) {
            EventHandler.on(this._element, this.constructor.eventName(EVENT_CLICK_BS), this._config.selector, event => {
              const context = this._initializeOnDelegatedTarget(event);
              // MODIFIED LOGIC HERE
              if (context._isShown() && context._activeTrigger[TRIGGER_CLICK]) {
                context._activeTrigger[TRIGGER_CLICK] = false;
              } else {
                context._activeTrigger[TRIGGER_CLICK] = true;
              }
              context.toggle();
            });
          } else if (trigger !== TRIGGER_MANUAL) {
            const eventIn = trigger === TRIGGER_HOVER ? this.constructor.eventName(EVENT_MOUSEENTER) : this.constructor.eventName(EVENT_FOCUSIN);
            const eventOut = trigger === TRIGGER_HOVER ? this.constructor.eventName(EVENT_MOUSELEAVE) : this.constructor.eventName(EVENT_FOCUSOUT);
            EventHandler.on(this._element, eventIn, this._config.selector, event => {
              const context = this._initializeOnDelegatedTarget(event);
              context._activeTrigger[event.type === EVENT_FOCUSIN ? TRIGGER_FOCUS : TRIGGER_HOVER] = true;
              context._enter();
            });
            EventHandler.on(this._element, eventOut, this._config.selector, event => {
              const context = this._initializeOnDelegatedTarget(event);
              const relatedTarget = event.relatedTarget; // Store relatedTarget
              context._activeTrigger[event.type === EVENT_FOCUSOUT ? TRIGGER_FOCUS : TRIGGER_HOVER] =
                (context._element && relatedTarget) ? context._element.contains(relatedTarget) : false; // Check context._element
              context._leave();
            });
          }
        }
        this._hideModalHandler = () => { if (this._element) { this.hide(); }};
        const closestModal = this._element ? this._element.closest(SELECTOR_MODAL) : null;
        if (closestModal) { EventHandler.on(closestModal, EVENT_MODAL_HIDE, this._hideModalHandler); }
      }
      _fixTitle() {
        const title = this._element.getAttribute('title');
        if (!title) { return; }
        if (!this._element.getAttribute('aria-label') && !this._element.textContent.trim()) { this._element.setAttribute('aria-label', title); }
        this._element.setAttribute('data-bs-original-title', title);
        this._element.removeAttribute('title');
      }
      _enter() {
        if (this._isShown() || this._isHovered) { this._isHovered = true; return; }
        this._isHovered = true;
        this._setTimeout(() => { if (this._isHovered) { this.show(); }}, this._config.delay.show);
      }
      _leave() {
        if (this._isWithActiveTrigger()) { return; }
        this._isHovered = false;
        this._setTimeout(() => { if (!this._isHovered) { this.hide(); }}, this._config.delay.hide);
      }
      _setTimeout(handler, timeout) { clearTimeout(this._timeout); this._timeout = setTimeout(handler, timeout); }
      _isWithActiveTrigger() { return Object.values(this._activeTrigger).includes(true); }
      _configAfterMerge(config) { // Overridden from BaseComponent
        config.container = config.container === false ? document.body : utilGetElement(config.container, this._element);
        if (typeof config.delay === 'number') { config.delay = { show: config.delay, hide: config.delay }; }
        if (typeof config.title === 'number') { config.title = config.title.toString(); }
        if (typeof config.content === 'number') { config.content = config.content.toString(); }
        return config;
      }
      _getDelegateConfig() {
        const config = {};
        for (const [key, value] of Object.entries(this._config)) {
          if (this.constructor.Default[key] !== value) { config[key] = value; }
        }
        config.selector = false; config.trigger = 'manual';
        return config;
      }
      _disposePopper() {
        if (this._popper) { this._popper.destroy(); this._popper = null; }
        if (this.tip) { this.tip.remove(); this.tip = null; }
      }
      // static jQueryInterface and defineJQueryPlugin are part of Bootstrap's structure
      static jQueryInterface(config) { /* ... */ }
    }
    utilDefineJQueryPlugin(Tooltip); // Call the define plugin function
    export default Tooltip;
    </script>

    <script type="module" id="bs-popover">
    // js/src/popover.js
    import Tooltip from '#bs-tooltip';
    import { defineJQueryPlugin as utilDefineJQueryPlugin } from '#bs-util-index';

    const NAME = 'popover'; // Static NAME for BaseComponent via Tooltip
    const SELECTOR_TITLE = '.popover-header';
    const SELECTOR_CONTENT = '.popover-body';

    const Default = {
      ...Tooltip.Default, content: '', offset: [0, 8], placement: 'right',
      template: '<div class="popover" role="tooltip"><div class="popover-arrow"></div><h3 class="popover-header"></h3><div class="popover-body"></div></div>',
      trigger: 'click'
    };
    const DefaultType = { ...Tooltip.DefaultType, content: '(null|string|element|function)' };

    class Popover extends Tooltip {
      static get Default() { return Default; }
      static get DefaultType() { return DefaultType; }
      static get NAME() { return NAME; } // Required by BaseComponent
      _isWithContent() { return this._getTitle() || this._getContent(); }
      _getContentForTemplate() { return { [SELECTOR_TITLE]: this._getTitle(), [SELECTOR_CONTENT]: this._getContent() }; }
      _getContent() { return this._resolvePossibleFunction(this._config.content); }
      // static jQueryInterface and defineJQueryPlugin are part of Bootstrap's structure
      static jQueryInterface(config) { /* ... */ }
    }
    utilDefineJQueryPlugin(Popover);

    if (typeof window.bootstrap === 'undefined') { window.bootstrap = {}; }
    window.bootstrap.Popover = Popover; // Make it available globally

    export default Popover;
    </script>

    <script type="module">
        // Final initialization script
        const popoverTriggerEl = document.getElementById('testPopover');
        // Use the globally exposed Popover
        if (window.bootstrap && window.bootstrap.Popover) {
            new window.bootstrap.Popover(popoverTriggerEl);
            console.log('Popover initialized using window.bootstrap.Popover');
        } else {
            // Fallback: Attempt to import Popover directly if it was exported and resolvable.
            // This is less likely to work with the current inline module structure without import maps.
            try {
                console.log('Attempting to import Popover from #bs-popover module...');
                const PopoverModule = await import('#bs-popover');
                if (PopoverModule.default) {
                    new PopoverModule.default(popoverTriggerEl);
                    console.log('Popover initialized using direct import from #bs-popover');
                } else {
                     throw new Error("#bs-popover did not provide a default export.");
                }
            } catch (e) {
                console.error('Failed to initialize Popover:', e);
                alert('Error initializing Popover. Check console for details. The `bootstrap.Popover` global might not have been set up correctly.');
            }
        }
    </script>
</body>
</html>
